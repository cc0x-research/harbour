{
  "language": "Solidity",
  "sources": {
    "@safe-global/safe-contracts/contracts/proxies/IProxyCreationCallback.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\nimport \"./SafeProxy.sol\";\n\n/**\n * @title IProxyCreationCallback\n * @dev An interface for a contract that implements a callback function to be executed after the creation of a proxy instance.\n */\ninterface IProxyCreationCallback {\n    /**\n     * @dev Function to be called after the creation of a SafeProxy instance.\n     * @param proxy The newly created SafeProxy instance.\n     * @param _singleton The address of the singleton contract used to create the proxy.\n     * @param initializer The initializer function call data.\n     * @param saltNonce The nonce used to generate the salt for the proxy deployment.\n     */\n    function proxyCreated(SafeProxy proxy, address _singleton, bytes calldata initializer, uint256 saltNonce) external;\n}\n"
    },
    "@safe-global/safe-contracts/contracts/proxies/SafeProxy.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/**\n * @title IProxy - Helper interface to access the singleton address of the Proxy on-chain.\n * @author Richard Meissner - @rmeissner\n */\ninterface IProxy {\n    function masterCopy() external view returns (address);\n}\n\n/**\n * @title SafeProxy - Generic proxy contract allows to execute all transactions applying the code of a master contract.\n * @author Stefan George - <stefan@gnosis.io>\n * @author Richard Meissner - <richard@gnosis.io>\n */\ncontract SafeProxy {\n    // Singleton always needs to be first declared variable, to ensure that it is at the same location in the contracts to which calls are delegated.\n    // To reduce deployment costs this variable is internal and needs to be retrieved via `getStorageAt`\n    address internal singleton;\n\n    /**\n     * @notice Constructor function sets address of singleton contract.\n     * @param _singleton Singleton address.\n     */\n    constructor(address _singleton) {\n        require(_singleton != address(0), \"Invalid singleton address provided\");\n        singleton = _singleton;\n    }\n\n    /// @dev Fallback function forwards all transactions and returns all received return data.\n    fallback() external payable {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let _singleton := and(sload(0), 0xffffffffffffffffffffffffffffffffffffffff)\n            // 0xa619486e == keccak(\"masterCopy()\"). The value is right padded to 32-bytes with 0s\n            if eq(calldataload(0), 0xa619486e00000000000000000000000000000000000000000000000000000000) {\n                mstore(0, _singleton)\n                return(0, 0x20)\n            }\n            calldatacopy(0, 0, calldatasize())\n            let success := delegatecall(gas(), _singleton, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            if eq(success, 0) {\n                revert(0, returndatasize())\n            }\n            return(0, returndatasize())\n        }\n    }\n}\n"
    },
    "@safe-global/safe-contracts/contracts/proxies/SafeProxyFactory.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"./SafeProxy.sol\";\nimport \"./IProxyCreationCallback.sol\";\n\n/**\n * @title Proxy Factory - Allows to create a new proxy contract and execute a message call to the new proxy within one transaction.\n * @author Stefan George - @Georgi87\n */\ncontract SafeProxyFactory {\n    event ProxyCreation(SafeProxy indexed proxy, address singleton);\n\n    /// @dev Allows to retrieve the creation code used for the Proxy deployment. With this it is easily possible to calculate predicted address.\n    function proxyCreationCode() public pure returns (bytes memory) {\n        return type(SafeProxy).creationCode;\n    }\n\n    /**\n     * @notice Internal method to create a new proxy contract using CREATE2. Optionally executes an initializer call to a new proxy.\n     * @param _singleton Address of singleton contract. Must be deployed at the time of execution.\n     * @param initializer (Optional) Payload for a message call to be sent to a new proxy contract.\n     * @param salt Create2 salt to use for calculating the address of the new proxy contract.\n     * @return proxy Address of the new proxy contract.\n     */\n    function deployProxy(address _singleton, bytes memory initializer, bytes32 salt) internal returns (SafeProxy proxy) {\n        require(isContract(_singleton), \"Singleton contract not deployed\");\n\n        bytes memory deploymentData = abi.encodePacked(type(SafeProxy).creationCode, uint256(uint160(_singleton)));\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            proxy := create2(0x0, add(0x20, deploymentData), mload(deploymentData), salt)\n        }\n        require(address(proxy) != address(0), \"Create2 call failed\");\n\n        if (initializer.length > 0) {\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                if eq(call(gas(), proxy, 0, add(initializer, 0x20), mload(initializer), 0, 0), 0) {\n                    revert(0, 0)\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Deploys a new proxy with `_singleton` singleton and `saltNonce` salt. Optionally executes an initializer call to a new proxy.\n     * @param _singleton Address of singleton contract. Must be deployed at the time of execution.\n     * @param initializer Payload for a message call to be sent to a new proxy contract.\n     * @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\n     */\n    function createProxyWithNonce(address _singleton, bytes memory initializer, uint256 saltNonce) public returns (SafeProxy proxy) {\n        // If the initializer changes the proxy address should change too. Hashing the initializer data is cheaper than just concatinating it\n        bytes32 salt = keccak256(abi.encodePacked(keccak256(initializer), saltNonce));\n        proxy = deployProxy(_singleton, initializer, salt);\n        emit ProxyCreation(proxy, _singleton);\n    }\n\n    /**\n     * @notice Deploys a new chain-specific proxy with `_singleton` singleton and `saltNonce` salt. Optionally executes an initializer call to a new proxy.\n     * @dev Allows to create a new proxy contract that should exist only on 1 network (e.g. specific governance or admin accounts)\n     *      by including the chain id in the create2 salt. Such proxies cannot be created on other networks by replaying the transaction.\n     * @param _singleton Address of singleton contract. Must be deployed at the time of execution.\n     * @param initializer Payload for a message call to be sent to a new proxy contract.\n     * @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\n     */\n    function createChainSpecificProxyWithNonce(\n        address _singleton,\n        bytes memory initializer,\n        uint256 saltNonce\n    ) public returns (SafeProxy proxy) {\n        // If the initializer changes the proxy address should change too. Hashing the initializer data is cheaper than just concatinating it\n        bytes32 salt = keccak256(abi.encodePacked(keccak256(initializer), saltNonce, getChainId()));\n        proxy = deployProxy(_singleton, initializer, salt);\n        emit ProxyCreation(proxy, _singleton);\n    }\n\n    /**\n     * @notice Deploy a new proxy with `_singleton` singleton and `saltNonce` salt.\n     *         Optionally executes an initializer call to a new proxy and calls a specified callback address `callback`.\n     * @param _singleton Address of singleton contract. Must be deployed at the time of execution.\n     * @param initializer Payload for a message call to be sent to a new proxy contract.\n     * @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\n     * @param callback Callback that will be invoked after the new proxy contract has been successfully deployed and initialized.\n     */\n    function createProxyWithCallback(\n        address _singleton,\n        bytes memory initializer,\n        uint256 saltNonce,\n        IProxyCreationCallback callback\n    ) public returns (SafeProxy proxy) {\n        uint256 saltNonceWithCallback = uint256(keccak256(abi.encodePacked(saltNonce, callback)));\n        proxy = createProxyWithNonce(_singleton, initializer, saltNonceWithCallback);\n        if (address(callback) != address(0)) callback.proxyCreated(proxy, _singleton, initializer, saltNonce);\n    }\n\n    /**\n     * @notice Returns true if `account` is a contract.\n     * @dev This function will return false if invoked during the constructor of a contract,\n     *      as the code is not actually created until after the constructor finishes.\n     * @param account The address being queried\n     * @return True if `account` is a contract\n     */\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @notice Returns the ID of the chain the contract is currently deployed on.\n     * @return The ID of the current chain as a uint256.\n     */\n    function getChainId() public view returns (uint256) {\n        uint256 id;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            id := chainid()\n        }\n        return id;\n    }\n}\n"
    },
    "src/SafeInternationalHarbour.sol": {
      "content": "// SPDX-License-Identifier: GNU GPLv3\npragma solidity ^0.8.29;\n\n/**\n * @title SafeInternationalHarbour\n * @notice Permissionless, append‑only registry that lets **any EOA signer** publish Safe\n *         transactions (\"SafeTx\") and their signatures. Clients without an off‑chain indexer can reconstruct the full multisig payload with only:\n *         1. the Safe address;\n *         2. the target `chainId`;\n *         3. the Safe `nonce`; and\n *         4. the current Safe owners set.\n *\n * Each unique `safeTxHash` (EIP‑712 digest of the SafeTx struct) is persisted **once** together with\n * its parameters. Signatures are appended under the composite key\n * `(signer, safe, chainId, nonce)`, enabling on‑chain, gas‑efficient look‑ups.\n *\n * ### ⚠️ Contract‑based signers unsupported\n * Only ECDSA signatures from externally‑owned accounts (EOAs) are supported. Contract wallets that\n * rely on ERC‑1271 or similar cannot be verified on‑chain in a chain‑agnostic way and are therefore\n * **not supported**.\n *\n * @dev The {SignatureStored} event is the only hook required by indexers; however, the contract is\n *      fully functional without any off‑chain infrastructure.\n */\ncontract SafeInternationalHarbour {\n    // ------------------------------------------------------------------\n    // Errors\n    // ------------------------------------------------------------------\n\n    /// Thrown when a signature blob is not exactly 65 bytes.\n    error InvalidECDSASignatureLength();\n\n    /// Thrown if `ecrecover` yields `address(0)`.\n    error InvalidSignature();\n\n    /// Thrown if the S value of the signature is not from the lower half of the curve.\n    error InvalidSignatureSValue();\n\n    /// Thrown when a value doesn't fit in a uint128.\n    error ValueDoesNotFitInUint128();\n\n    /// @notice Thrown when attempting to store a signature for a transaction (safeTxHash)\n    /// that the signer has already provided a signature for.\n    /// @param signer Signer address.\n    /// @param safeTxHash The EIP-712 hash of the Safe transaction.\n    error SignerAlreadySignedTransaction(address signer, bytes32 safeTxHash);\n\n    // ------------------------------------------------------------------\n    // Constants\n    // ------------------------------------------------------------------\n\n    /// The hashes must be the same as the ones in the Safe contract:\n    /// https://github.com/safe-global/safe-smart-account/blob/b115c4c5fe23dca6aefeeccc73d312ddd23322c2/contracts/Safe.sol#L54-L63\n    /// These should cover Safe versions 1.3.0 and 1.4.1\n    /// keccak256(\"EIP712Domain(uint256 chainId,address verifyingContract)\")\n    bytes32 private constant _DOMAIN_TYPEHASH =\n        0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218;\n\n    /// keccak256(\"SafeTx(address to,uint256 value,bytes data,uint8 operation,uint256 safeTxGas,uint256 baseGas,uint256 gasPrice,address gasToken,address refundReceiver,uint256 nonce)\")\n    bytes32 private constant _SAFE_TX_TYPEHASH =\n        0xbb8310d486368db6bd6f849402fdd73ad53d316b5a4b2644ad6efe0f941286d8;\n\n    /// The lower bound of the S value for a valid secp256k1 signature.\n    /// https://github.com/safe-global/safe-smart-account/blob/b115c4c5fe23dca6aefeeccc73d312ddd23322c2/contracts/Safe.sol#L100\n    bytes32 private constant SECP256K1_LOW_S_BOUND =\n        0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0;\n\n    // ------------------------------------------------------------------\n    // Data structures\n    // ------------------------------------------------------------------\n\n    /**\n     * @dev Storage optimised mirror of the SafeTx struct used by Safe contracts.\n     *      Non-optimised version uses uint256 for:\n     *      - value\n     *      - safeTxGas\n     *      - baseGas\n     *      - gasPrice\n     */\n    struct SafeTransaction {\n        // stored, operation and to will be packed into the same storage slot\n        bool stored;\n        uint8 operation;\n        address to;\n        uint128 value;\n        uint128 safeTxGas;\n        uint128 baseGas;\n        uint128 gasPrice;\n        address gasToken;\n        address refundReceiver;\n        bytes data;\n    }\n\n    /**\n     * @dev Minimal, storage‑optimised representation of an ECDSA signature.\n     */\n    struct SignatureDataWithTxHashIndex {\n        bytes32 r;\n        // vs is the compact representation of s and v coming from\n        // EIP-2098: https://eips.ethereum.org/EIPS/eip-2098\n        bytes32 vs;\n        bytes32 txHash; // EIP‑712 digest this signature belongs to\n    }\n\n    // ------------------------------------------------------------------\n    // Storage\n    // ------------------------------------------------------------------\n\n    /// Mapping `safeTxHash → SafeTransaction` parameters\n    mapping(bytes32 => SafeTransaction) private _txDetails;\n\n    /// Mapping `signer → safe → chainId → nonce → SignatureDataWithTxHashIndex[]`\n    /// Stores the list of signatures provided by a signer for a given Safe context.\n    /// Note: A single list entry here could contain signatures for *different* `safeTxHash` values\n    /// if those transactions share the same (safe, chainId, nonce). Use `_hasSignerSignedTx`\n    /// to ensure a signer only signs a specific `safeTxHash` once.\n    mapping(address signer => mapping(address safe => mapping(uint256 chainId => mapping(uint256 nonce => SignatureDataWithTxHashIndex[]))))\n        private _sigData;\n\n    /// @dev Tracks if a signer has already submitted *any* signature for a specific safeTxHash,\n    ///      preventing duplicate signatures for the *exact same* transaction digest.\n    ///      This complements `_sigData` by ensuring uniqueness per (safeTxHash, signer) pair.\n    /// Mapping `safeTxHash → signer → bool`\n    mapping(bytes32 safeTxHash => mapping(address signer => bool))\n        private _hasSignerSignedTx;\n\n    // ------------------------------------------------------------------\n    // Events\n    // ------------------------------------------------------------------\n\n    /**\n     * @notice Emitted whenever a new signature is stored (and possibly the parameters on first sight).\n     *\n     * @param signer     Address recovered from the provided signature.\n     * @param safe       Safe Smart‑Account the transaction targets.\n     * @param safeTxHash EIP‑712 hash identifying the SafeTx.\n     * @param chainId    Intended execution chain.\n     * @param nonce      Safe nonce.\n     * @param listIndex  Position of the signature in the signer‑specific array.\n     */\n    event SignatureStored(\n        address indexed signer,\n        address indexed safe,\n        bytes32 indexed safeTxHash,\n        uint256 chainId,\n        uint256 nonce,\n        uint256 listIndex\n    );\n\n    /**\n     * @notice Emitted when a transaction is first stored.\n     * @param safeTxHash EIP-712 hash identifying the SafeTx.\n     * @param safe       Safe Smart-Account the transaction targets.\n     * @param chainId    Intended execution chain.\n     * @param nonce      Safe nonce.\n     * @param to         Destination of the inner call/delegatecall.\n     * @param value      ETH value forwarded by the Safe.\n     * @param operation  0 = CALL, 1 = DELEGATECALL.\n     * @param safeTxGas  Gas forwarded to the inner call.\n     * @param baseGas    Fixed overhead reimbursed to the submitting signer.\n     * @param gasPrice   Gas price used for reimbursement.\n     * @param gasToken   ERC-20 token address for refunds.\n     * @param refundReceiver Address receiving the gas refund.\n     * @param data       Calldata executed by the Safe.\n     */\n    event NewTransaction(\n        bytes32 indexed safeTxHash,\n        address indexed safe,\n        uint256 indexed chainId,\n        uint256 nonce,\n        address to,\n        uint256 value,\n        uint8 operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address refundReceiver,\n        bytes data\n    );\n\n    // ------------------------------------------------------------------\n    // External & public functions\n    // ------------------------------------------------------------------\n\n    /**\n     * @notice Publish a Safe transaction and/or append a signature to it.\n     *\n     * @dev If `safeTxHash` has been seen before, its parameters are *not* validated nor overwritten –\n     *      the call simply appends the `(r,s)` pair for `signer`.\n     *\n     * @param safeAddress    Target Safe Smart‑Account.\n     * @param chainId        Chain id the transaction is meant for.\n     * @param nonce          Safe nonce.\n     * @param to             Destination of the inner call/delegatecall.\n     * @param value          ETH value forwarded by the Safe.\n     * @param data           Calldata executed by the Safe.\n     * @param operation      0 = CALL, 1 = DELEGATECALL.\n     * @param safeTxGas      Gas forwarded to the inner call.\n     * @param baseGas        Fixed overhead reimbursed to the submitting signer.\n     * @param gasPrice       Gas price used for reimbursement.\n     * @param gasToken       ERC‑20 token address for refunds (`address(0)` = ETH).\n     * @param refundReceiver Address receiving the gas refund.\n     * @param signature      **Single** 65‑byte ECDSA signature.\n     *\n     * @return listIndex     Index of the stored signature in the signer‑specific list.\n     *\n     * @custom:events Emits {SignatureStored}.\n     */\n    function enqueueTransaction(\n        address safeAddress,\n        uint256 chainId,\n        uint256 nonce,\n        address to,\n        uint256 value,\n        bytes calldata data,\n        uint8 operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address refundReceiver,\n        bytes calldata signature\n    ) external returns (uint256 listIndex) {\n        require(signature.length == 65, InvalidECDSASignatureLength());\n\n        // ------------------------------------------------------------------\n        // Build the EIP‑712 digest that uniquely identifies the SafeTx\n        // ------------------------------------------------------------------\n        bytes32 safeTxHash = _computeSafeTxHash(\n            safeAddress,\n            chainId,\n            nonce,\n            to,\n            value,\n            data,\n            operation,\n            safeTxGas,\n            baseGas,\n            gasPrice,\n            gasToken,\n            refundReceiver\n        );\n\n        // Recover signer and split signature into (r,vs)\n        (address signer, bytes32 r, bytes32 vs) = _recoverSigner(\n            safeTxHash,\n            signature\n        );\n\n        // --- DUPLICATE TRANSACTION SIGNATURE CHECK ---\n        // Revert if this signer has already submitted *any* signature for this *exact* safeTxHash\n        require(\n            !_hasSignerSignedTx[safeTxHash][signer],\n            SignerAlreadySignedTransaction(signer, safeTxHash)\n        );\n\n        // Store parameters only once (idempotent write)\n        SafeTransaction storage slot = _txDetails[safeTxHash];\n        if (!slot.stored) {\n            // first encounter → persist full parameter set\n            slot.stored = true;\n            slot.to = to;\n            slot.operation = operation;\n\n            // Writing to storage is expensive, so we only write if the value is non-zero\n            if (value > 0) {\n                slot.value = _safeCastUint256ToUint128(value);\n            }\n            if (safeTxGas > 0) {\n                slot.safeTxGas = _safeCastUint256ToUint128(safeTxGas);\n            }\n            if (baseGas > 0) {\n                slot.baseGas = _safeCastUint256ToUint128(baseGas);\n            }\n            if (gasPrice > 0) {\n                slot.gasPrice = _safeCastUint256ToUint128(gasPrice);\n            }\n            if (gasToken != address(0)) {\n                slot.gasToken = gasToken;\n            }\n            if (refundReceiver != address(0)) {\n                slot.refundReceiver = refundReceiver;\n            }\n            if (data.length > 0) {\n                slot.data = data;\n            }\n\n            emit NewTransaction(\n                safeTxHash,\n                safeAddress,\n                chainId,\n                nonce,\n                to,\n                value,\n                operation,\n                safeTxGas,\n                baseGas,\n                gasPrice,\n                gasToken,\n                refundReceiver,\n                data\n            );\n        }\n\n        // Mark that this signer has now signed this specific transaction hash\n        _hasSignerSignedTx[safeTxHash][signer] = true;\n\n        // Append the (r,vs) pair for this signer\n        SignatureDataWithTxHashIndex[] storage list = _sigData[signer][\n            safeAddress\n        ][chainId][nonce];\n        list.push(\n            SignatureDataWithTxHashIndex({r: r, vs: vs, txHash: safeTxHash})\n        );\n        unchecked {\n            listIndex = list.length - 1; // gas‑free length‑1 because of unchecked\n        }\n\n        emit SignatureStored(\n            signer,\n            safeAddress,\n            safeTxHash,\n            chainId,\n            nonce,\n            listIndex\n        );\n    }\n\n    /**\n     * @notice Retrieve the full parameter set of a Safe transaction.\n     *\n     * @param safeTxHash EIP‑712 digest of the transaction.\n     *\n     * @return txParams Struct with all SafeTx parameters (zero‑initialised if unknown).\n     */\n    function retrieveTransaction(\n        bytes32 safeTxHash\n    ) external view returns (SafeTransaction memory txParams) {\n        txParams = _txDetails[safeTxHash];\n    }\n\n    /**\n     * @notice Paginated getter for signature entries.\n     *\n     * @param signerAddress Address that created the signatures.\n     * @param safeAddress   Safe Smart‑Account.\n     * @param chainId       Target chain id.\n     * @param nonce         Safe nonce.\n     * @param start         Zero‑based start index of the slice.\n     * @param count         Maximum number of entries to return.\n     *\n     * @return page       Array slice `[start … start+count)` (may be shorter).\n     * @return totalCount Total number of signatures stored for the tuple.\n     */\n    function retrieveSignatures(\n        address signerAddress,\n        address safeAddress,\n        uint256 chainId,\n        uint256 nonce,\n        uint256 start,\n        uint256 count\n    )\n        external\n        view\n        returns (SignatureDataWithTxHashIndex[] memory page, uint256 totalCount)\n    {\n        SignatureDataWithTxHashIndex[] storage all = _sigData[signerAddress][\n            safeAddress\n        ][chainId][nonce];\n        totalCount = all.length;\n        if (start >= totalCount)\n            return (new SignatureDataWithTxHashIndex[](0), totalCount);\n\n        uint256 end = start + count;\n        if (end > totalCount) end = totalCount;\n        uint256 len = end - start;\n\n        page = new SignatureDataWithTxHashIndex[](len);\n        for (uint256 i; i < len; ++i) {\n            page[i] = all[start + i];\n        }\n    }\n\n    /**\n     * @notice Convenience getter returning the **number** of signatures stored for the key tuple.\n     *\n     * @param signerAddress Signer address.\n     * @param safeAddress   Safe Smart‑Account.\n     * @param chainId       Target chain id.\n     * @param nonce         Safe nonce.\n     *\n     * @return count Length of the signature list.\n     */\n    function retrieveSignaturesCount(\n        address signerAddress,\n        address safeAddress,\n        uint256 chainId,\n        uint256 nonce\n    ) external view returns (uint256 count) {\n        count = _sigData[signerAddress][safeAddress][chainId][nonce].length;\n    }\n\n    /**\n     * @notice Computes the unique EIP-712 digest for a SafeTx using the provided parameters and domain.\n     * @param safeAddress Address of the target Safe Smart Account.\n     * @param chainId Chain ID included in the domain separator.\n     * @param nonce Safe transaction nonce.\n     * @param to Target address the Safe will call.\n     * @param value ETH value to be sent with the call.\n     * @param data Call data executed by the Safe.\n     * @param operation Operation type: 0 = CALL, 1 = DELEGATECALL.\n     * @param safeTxGas Gas limit for the Safe's internal execution.\n     * @param baseGas Base gas overhead for reimbursement.\n     * @param gasPrice Gas price used for reimbursement calculation.\n     * @param gasToken Token address for refunds (0x0 for ETH).\n     * @param refundReceiver Address to receive gas refunds.\n     * @return safeTxHash Keccak256 digest of the EIP-712 encoded SafeTx.\n     */\n    function _computeSafeTxHash(\n        address safeAddress,\n        uint256 chainId,\n        uint256 nonce,\n        address to,\n        uint256 value,\n        bytes calldata data,\n        uint8 operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address refundReceiver\n    ) private pure returns (bytes32 safeTxHash) {\n        bytes32 domainSeparator = keccak256(\n            abi.encode(_DOMAIN_TYPEHASH, chainId, safeAddress)\n        );\n        bytes32 structHash = keccak256(\n            abi.encode(\n                _SAFE_TX_TYPEHASH,\n                to,\n                value,\n                keccak256(data),\n                operation,\n                safeTxGas,\n                baseGas,\n                gasPrice,\n                gasToken,\n                refundReceiver,\n                nonce\n            )\n        );\n        safeTxHash = keccak256(\n            abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash)\n        );\n    }\n\n    /**\n     * @notice Splits a 65-byte ECDSA signature into its components and recovers the signer address.\n     * @param digest The message or data hash to verify (EIP-712 digest or eth_sign prefixed).\n     * @param sig Concatenated 65-byte ECDSA signature (r || s || v).\n     * @return signer The address that produced the signature (EOA).\n     * @return r First 32 bytes of the ECDSA signature.\n     * @return vs Compact representation of s and v coming from EIP-2098.\n     * @dev Supports both EIP-712 and eth_sign flows by detecting v > 30 and applying the Ethereum Signed Message prefix.\n     */\n    function _recoverSigner(\n        bytes32 digest,\n        bytes calldata sig\n    ) private pure returns (address signer, bytes32 r, bytes32 vs) {\n        uint8 v;\n        bytes32 s;\n        // solhint-disable-next-line no-inline-assembly\n        assembly (\"memory-safe\") {\n            r := calldataload(sig.offset)\n            s := calldataload(add(sig.offset, 0x20))\n            v := byte(0, calldataload(add(sig.offset, 0x40)))\n        }\n        require(s <= SECP256K1_LOW_S_BOUND, InvalidSignatureSValue());\n\n        signer = ecrecover(digest, v, r, s);\n        require(signer != address(0), InvalidSignature());\n        // solhint-disable-next-line no-inline-assembly\n        assembly (\"memory-safe\") {\n            // Equivalent to:\n            // vs = bytes32(uint256(v - 27)  << 255 | uint256(s));\n            // Which should avoid conversion between uint256 and bytes32\n            vs := or(shl(255, sub(v, 27)), s)\n        }\n    }\n\n    function _safeCastUint256ToUint128(\n        uint256 value\n    ) private pure returns (uint128) {\n        require(value <= type(uint128).max, ValueDoesNotFitInUint128());\n        return uint128(value);\n    }\n}\n"
    },
    "src/test/TestImports.sol": {
      "content": "// SPDX-License-Identifier: GNU GPLv3\n/* solhint-disable no-unused-import */\npragma solidity ^0.8.29;\n\nimport {\n    SafeProxyFactory\n} from \"@safe-global/safe-contracts/contracts/proxies/SafeProxyFactory.sol\";\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 10000000
    },
    "viaIR": true,
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}