{
  "language": "Solidity",
  "sources": {
    "src/SafeInternationalHarbour.sol": {
      "content": "// SPDX-License-Identifier: GNU GPLv3\npragma solidity ^0.8.29;\n\n/**\n * @title SafeInternationalHarbour\n * @notice Permissionless, append‑only registry that lets **any EOA signer** publish Safe\n *         transactions (\"SafeTx\") and their signatures. Clients without an off‑chain indexer can reconstruct the full multisig payload with only:\n *         1. the Safe address;\n *         2. the target `chainId`;\n *         3. the Safe `nonce`; and\n *         4. the current Safe owners set.\n *\n * Each unique `safeTxHash` (EIP‑712 digest of the SafeTx struct) is persisted **once** together with\n * its parameters. Signatures are appended under the composite key\n * `(signer, safe, chainId, nonce)`, enabling on‑chain, gas‑efficient look‑ups.\n *\n * ### ⚠️ Contract‑based signers unsupported\n * Only ECDSA signatures from externally‑owned accounts (EOAs) are supported. Contract wallets that\n * rely on ERC‑1271 or similar cannot be verified on‑chain in a chain‑agnostic way and are therefore\n * **not supported**.\n *\n * @dev The {SignatureStored} event is the only hook required by indexers; however, the contract is\n *      fully functional without any off‑chain infrastructure.\n */\ncontract SafeInternationalHarbour {\n    // ------------------------------------------------------------------\n    // Errors\n    // ------------------------------------------------------------------\n\n    /// Thrown when a signature blob is not exactly 65 bytes.\n    error InvalidECDSASignatureLength();\n\n    /// Thrown if `ecrecover` yields `address(0)`.\n    error InvalidSignature();\n\n    /// Thrown if the S value of the signature is not from the lower half of the curve.\n    error InvalidSignatureSValue();\n\n    /// Thrown when a value doesn't fit in a uint128.\n    error ValueDoesNotFitInUint128();\n\n    /// @notice Thrown when attempting to store a signature for a transaction (safeTxHash)\n    /// that the signer has already provided a signature for.\n    /// @param signer Signer address.\n    /// @param safeTxHash The EIP-712 hash of the Safe transaction.\n    error SignerAlreadySignedTransaction(address signer, bytes32 safeTxHash);\n\n    // ------------------------------------------------------------------\n    // Constants\n    // ------------------------------------------------------------------\n\n    /// The hashes must be the same as the ones in the Safe contract:\n    /// https://github.com/safe-global/safe-smart-account/blob/b115c4c5fe23dca6aefeeccc73d312ddd23322c2/contracts/Safe.sol#L54-L63\n    /// These should cover Safe versions 1.3.0 and 1.4.1\n    /// keccak256(\"EIP712Domain(uint256 chainId,address verifyingContract)\")\n    bytes32 private constant _DOMAIN_TYPEHASH =\n        0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218;\n\n    /// keccak256(\"SafeTx(address to,uint256 value,bytes data,uint8 operation,uint256 safeTxGas,uint256 baseGas,uint256 gasPrice,address gasToken,address refundReceiver,uint256 nonce)\")\n    bytes32 private constant _SAFE_TX_TYPEHASH =\n        0xbb8310d486368db6bd6f849402fdd73ad53d316b5a4b2644ad6efe0f941286d8;\n\n    /// The lower bound of the S value for a valid secp256k1 signature.\n    /// https://github.com/safe-global/safe-smart-account/blob/b115c4c5fe23dca6aefeeccc73d312ddd23322c2/contracts/Safe.sol#L100\n    bytes32 private constant SECP256K1_LOW_S_BOUND =\n        0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0;\n\n    // ------------------------------------------------------------------\n    // Data structures\n    // ------------------------------------------------------------------\n\n    /**\n     * @dev Storage optimised mirror of the SafeTx struct used by Safe contracts.\n     *      Non-optimised version uses uint256 for:\n     *      - value\n     *      - safeTxGas\n     *      - baseGas\n     *      - gasPrice\n     */\n    struct SafeTransaction {\n        // stored, operation and to will be packed into the same storage slot\n        bool stored;\n        uint8 operation;\n        address to;\n        uint128 value;\n        uint128 safeTxGas;\n        uint128 baseGas;\n        uint128 gasPrice;\n        address gasToken;\n        address refundReceiver;\n        bytes data;\n    }\n\n    /**\n     * @dev Minimal, storage‑optimised representation of an ECDSA signature.\n     */\n    struct SignatureDataWithTxHashIndex {\n        bytes32 r;\n        // vs is the compact representation of s and v coming from\n        // EIP-2098: https://eips.ethereum.org/EIPS/eip-2098\n        bytes32 vs;\n        bytes32 txHash; // EIP‑712 digest this signature belongs to\n    }\n\n    // ------------------------------------------------------------------\n    // Storage\n    // ------------------------------------------------------------------\n\n    /// Mapping `safeTxHash → SafeTransaction` parameters\n    mapping(bytes32 => SafeTransaction) private _txDetails;\n\n    /// Mapping `signer → safe → chainId → nonce → SignatureDataWithTxHashIndex[]`\n    /// Stores the list of signatures provided by a signer for a given Safe context.\n    /// Note: A single list entry here could contain signatures for *different* `safeTxHash` values\n    /// if those transactions share the same (safe, chainId, nonce). Use `_hasSignerSignedTx`\n    /// to ensure a signer only signs a specific `safeTxHash` once.\n    mapping(address signer => mapping(address safe => mapping(uint256 chainId => mapping(uint256 nonce => SignatureDataWithTxHashIndex[]))))\n        private _sigData;\n\n    /// @dev Tracks if a signer has already submitted *any* signature for a specific safeTxHash,\n    ///      preventing duplicate signatures for the *exact same* transaction digest.\n    ///      This complements `_sigData` by ensuring uniqueness per (safeTxHash, signer) pair.\n    /// Mapping `safeTxHash → signer → bool`\n    mapping(bytes32 safeTxHash => mapping(address signer => bool))\n        private _hasSignerSignedTx;\n\n    // ------------------------------------------------------------------\n    // Events\n    // ------------------------------------------------------------------\n\n    /**\n     * @notice Emitted whenever a new signature is stored (and possibly the parameters on first sight).\n     *\n     * @param signer     Address recovered from the provided signature.\n     * @param safe       Safe Smart‑Account the transaction targets.\n     * @param safeTxHash EIP‑712 hash identifying the SafeTx.\n     * @param chainId    Intended execution chain.\n     * @param nonce      Safe nonce.\n     * @param listIndex  Position of the signature in the signer‑specific array.\n     */\n    event SignatureStored(\n        address indexed signer,\n        address indexed safe,\n        bytes32 indexed safeTxHash,\n        uint256 chainId,\n        uint256 nonce,\n        uint256 listIndex\n    );\n\n    /**\n     * @notice Emitted when a transaction is first stored.\n     * @param safeTxHash EIP-712 hash identifying the SafeTx.\n     * @param safe       Safe Smart-Account the transaction targets.\n     * @param chainId    Intended execution chain.\n     * @param nonce      Safe nonce.\n     * @param to         Destination of the inner call/delegatecall.\n     * @param value      ETH value forwarded by the Safe.\n     * @param operation  0 = CALL, 1 = DELEGATECALL.\n     * @param safeTxGas  Gas forwarded to the inner call.\n     * @param baseGas    Fixed overhead reimbursed to the submitting signer.\n     * @param gasPrice   Gas price used for reimbursement.\n     * @param gasToken   ERC-20 token address for refunds.\n     * @param refundReceiver Address receiving the gas refund.\n     * @param data       Calldata executed by the Safe.\n     */\n    event NewTransaction(\n        bytes32 indexed safeTxHash,\n        address indexed safe,\n        uint256 indexed chainId,\n        uint256 nonce,\n        address to,\n        uint256 value,\n        uint8 operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address refundReceiver,\n        bytes data\n    );\n\n    // ------------------------------------------------------------------\n    // External & public functions\n    // ------------------------------------------------------------------\n\n    /**\n     * @notice Publish a Safe transaction and/or append a signature to it.\n     *\n     * @dev If `safeTxHash` has been seen before, its parameters are *not* validated nor overwritten –\n     *      the call simply appends the `(r,s)` pair for `signer`.\n     *\n     * @param safeAddress    Target Safe Smart‑Account.\n     * @param chainId        Chain id the transaction is meant for.\n     * @param nonce          Safe nonce.\n     * @param to             Destination of the inner call/delegatecall.\n     * @param value          ETH value forwarded by the Safe.\n     * @param data           Calldata executed by the Safe.\n     * @param operation      0 = CALL, 1 = DELEGATECALL.\n     * @param safeTxGas      Gas forwarded to the inner call.\n     * @param baseGas        Fixed overhead reimbursed to the submitting signer.\n     * @param gasPrice       Gas price used for reimbursement.\n     * @param gasToken       ERC‑20 token address for refunds (`address(0)` = ETH).\n     * @param refundReceiver Address receiving the gas refund.\n     * @param signature      **Single** 65‑byte ECDSA signature.\n     *\n     * @return listIndex     Index of the stored signature in the signer‑specific list.\n     *\n     * @custom:events Emits {SignatureStored}.\n     */\n    function enqueueTransaction(\n        address safeAddress,\n        uint256 chainId,\n        uint256 nonce,\n        address to,\n        uint256 value,\n        bytes calldata data,\n        uint8 operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address refundReceiver,\n        bytes calldata signature\n    ) external returns (uint256 listIndex) {\n        require(signature.length == 65, InvalidECDSASignatureLength());\n\n        // ------------------------------------------------------------------\n        // Build the EIP‑712 digest that uniquely identifies the SafeTx\n        // ------------------------------------------------------------------\n        bytes32 safeTxHash = _computeSafeTxHash(\n            safeAddress,\n            chainId,\n            nonce,\n            to,\n            value,\n            data,\n            operation,\n            safeTxGas,\n            baseGas,\n            gasPrice,\n            gasToken,\n            refundReceiver\n        );\n\n        // Recover signer and split signature into (r,vs)\n        (address signer, bytes32 r, bytes32 vs) = _recoverSigner(\n            safeTxHash,\n            signature\n        );\n\n        // --- DUPLICATE TRANSACTION SIGNATURE CHECK ---\n        // Revert if this signer has already submitted *any* signature for this *exact* safeTxHash\n        require(\n            !_hasSignerSignedTx[safeTxHash][signer],\n            SignerAlreadySignedTransaction(signer, safeTxHash)\n        );\n\n        // Store parameters only once (idempotent write)\n        SafeTransaction storage slot = _txDetails[safeTxHash];\n        if (!slot.stored) {\n            // first encounter → persist full parameter set\n            slot.stored = true;\n            slot.to = to;\n            slot.operation = operation;\n\n            // Writing to storage is expensive, so we only write if the value is non-zero\n            if (value > 0) {\n                slot.value = _safeCastUint256ToUint128(value);\n            }\n            if (safeTxGas > 0) {\n                slot.safeTxGas = _safeCastUint256ToUint128(safeTxGas);\n            }\n            if (baseGas > 0) {\n                slot.baseGas = _safeCastUint256ToUint128(baseGas);\n            }\n            if (gasPrice > 0) {\n                slot.gasPrice = _safeCastUint256ToUint128(gasPrice);\n            }\n            if (gasToken != address(0)) {\n                slot.gasToken = gasToken;\n            }\n            if (refundReceiver != address(0)) {\n                slot.refundReceiver = refundReceiver;\n            }\n            if (data.length > 0) {\n                slot.data = data;\n            }\n\n            emit NewTransaction(\n                safeTxHash,\n                safeAddress,\n                chainId,\n                nonce,\n                to,\n                value,\n                operation,\n                safeTxGas,\n                baseGas,\n                gasPrice,\n                gasToken,\n                refundReceiver,\n                data\n            );\n        }\n\n        // Mark that this signer has now signed this specific transaction hash\n        _hasSignerSignedTx[safeTxHash][signer] = true;\n\n        // Append the (r,vs) pair for this signer\n        SignatureDataWithTxHashIndex[] storage list = _sigData[signer][\n            safeAddress\n        ][chainId][nonce];\n        list.push(\n            SignatureDataWithTxHashIndex({r: r, vs: vs, txHash: safeTxHash})\n        );\n        unchecked {\n            listIndex = list.length - 1; // gas‑free length‑1 because of unchecked\n        }\n\n        emit SignatureStored(\n            signer,\n            safeAddress,\n            safeTxHash,\n            chainId,\n            nonce,\n            listIndex\n        );\n    }\n\n    /**\n     * @notice Retrieve the full parameter set of a Safe transaction.\n     *\n     * @param safeTxHash EIP‑712 digest of the transaction.\n     *\n     * @return txParams Struct with all SafeTx parameters (zero‑initialised if unknown).\n     */\n    function retrieveTransaction(\n        bytes32 safeTxHash\n    ) external view returns (SafeTransaction memory txParams) {\n        txParams = _txDetails[safeTxHash];\n    }\n\n    /**\n     * @notice Paginated getter for signature entries.\n     *\n     * @param signerAddress Address that created the signatures.\n     * @param safeAddress   Safe Smart‑Account.\n     * @param chainId       Target chain id.\n     * @param nonce         Safe nonce.\n     * @param start         Zero‑based start index of the slice.\n     * @param count         Maximum number of entries to return.\n     *\n     * @return page       Array slice `[start … start+count)` (may be shorter).\n     * @return totalCount Total number of signatures stored for the tuple.\n     */\n    function retrieveSignatures(\n        address signerAddress,\n        address safeAddress,\n        uint256 chainId,\n        uint256 nonce,\n        uint256 start,\n        uint256 count\n    )\n        external\n        view\n        returns (SignatureDataWithTxHashIndex[] memory page, uint256 totalCount)\n    {\n        SignatureDataWithTxHashIndex[] storage all = _sigData[signerAddress][\n            safeAddress\n        ][chainId][nonce];\n        totalCount = all.length;\n        if (start >= totalCount)\n            return (new SignatureDataWithTxHashIndex[](0), totalCount);\n\n        uint256 end = start + count;\n        if (end > totalCount) end = totalCount;\n        uint256 len = end - start;\n\n        page = new SignatureDataWithTxHashIndex[](len);\n        for (uint256 i; i < len; ++i) {\n            page[i] = all[start + i];\n        }\n    }\n\n    /**\n     * @notice Convenience getter returning the **number** of signatures stored for the key tuple.\n     *\n     * @param signerAddress Signer address.\n     * @param safeAddress   Safe Smart‑Account.\n     * @param chainId       Target chain id.\n     * @param nonce         Safe nonce.\n     *\n     * @return count Length of the signature list.\n     */\n    function retrieveSignaturesCount(\n        address signerAddress,\n        address safeAddress,\n        uint256 chainId,\n        uint256 nonce\n    ) external view returns (uint256 count) {\n        count = _sigData[signerAddress][safeAddress][chainId][nonce].length;\n    }\n\n    /**\n     * @notice Computes the unique EIP-712 digest for a SafeTx using the provided parameters and domain.\n     * @param safeAddress Address of the target Safe Smart Account.\n     * @param chainId Chain ID included in the domain separator.\n     * @param nonce Safe transaction nonce.\n     * @param to Target address the Safe will call.\n     * @param value ETH value to be sent with the call.\n     * @param data Call data executed by the Safe.\n     * @param operation Operation type: 0 = CALL, 1 = DELEGATECALL.\n     * @param safeTxGas Gas limit for the Safe's internal execution.\n     * @param baseGas Base gas overhead for reimbursement.\n     * @param gasPrice Gas price used for reimbursement calculation.\n     * @param gasToken Token address for refunds (0x0 for ETH).\n     * @param refundReceiver Address to receive gas refunds.\n     * @return safeTxHash Keccak256 digest of the EIP-712 encoded SafeTx.\n     */\n    function _computeSafeTxHash(\n        address safeAddress,\n        uint256 chainId,\n        uint256 nonce,\n        address to,\n        uint256 value,\n        bytes calldata data,\n        uint8 operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address refundReceiver\n    ) private pure returns (bytes32 safeTxHash) {\n        bytes32 domainSeparator = keccak256(\n            abi.encode(_DOMAIN_TYPEHASH, chainId, safeAddress)\n        );\n        bytes32 structHash = keccak256(\n            abi.encode(\n                _SAFE_TX_TYPEHASH,\n                to,\n                value,\n                keccak256(data),\n                operation,\n                safeTxGas,\n                baseGas,\n                gasPrice,\n                gasToken,\n                refundReceiver,\n                nonce\n            )\n        );\n        safeTxHash = keccak256(\n            abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash)\n        );\n    }\n\n    /**\n     * @notice Splits a 65-byte ECDSA signature into its components and recovers the signer address.\n     * @param digest The message or data hash to verify (EIP-712 digest or eth_sign prefixed).\n     * @param sig Concatenated 65-byte ECDSA signature (r || s || v).\n     * @return signer The address that produced the signature (EOA).\n     * @return r First 32 bytes of the ECDSA signature.\n     * @return vs Compact representation of s and v coming from EIP-2098.\n     * @dev Supports both EIP-712 and eth_sign flows by detecting v > 30 and applying the Ethereum Signed Message prefix.\n     */\n    function _recoverSigner(\n        bytes32 digest,\n        bytes calldata sig\n    ) private pure returns (address signer, bytes32 r, bytes32 vs) {\n        uint8 v;\n        bytes32 s;\n        // solhint-disable-next-line no-inline-assembly\n        assembly (\"memory-safe\") {\n            r := calldataload(sig.offset)\n            s := calldataload(add(sig.offset, 0x20))\n            v := byte(0, calldataload(add(sig.offset, 0x40)))\n        }\n        require(s <= SECP256K1_LOW_S_BOUND, InvalidSignatureSValue());\n\n        signer = ecrecover(digest, v, r, s);\n        require(signer != address(0), InvalidSignature());\n        // solhint-disable-next-line no-inline-assembly\n        assembly (\"memory-safe\") {\n            // Equivalent to:\n            // vs = bytes32(uint256(v - 27)  << 255 | uint256(s));\n            // Which should avoid conversion between uint256 and bytes32\n            vs := or(shl(255, sub(v, 27)), s)\n        }\n    }\n\n    function _safeCastUint256ToUint128(\n        uint256 value\n    ) private pure returns (uint128) {\n        require(value <= type(uint128).max, ValueDoesNotFitInUint128());\n        return uint128(value);\n    }\n}\n"
    },
    "src/utils/SafeConfigurationFetcher.sol": {
      "content": "// SPDX-License-Identifier: GNU GPLv3\npragma solidity ^0.8.29;\n\n/// @notice Data structure representing a Safe configuration.\n/// @param owners The list of Safe owners.\n/// @param threshold Required confirmations for transactions.\n/// @param fallbackHandler Fallback handler contract address.\n/// @param nonce Current nonce of the Safe.\n/// @param modules Enabled Safe modules.\n/// @param guard Guard contract address.\nstruct SafeConfiguration {\n    address[] owners;\n    uint256 threshold;\n    address fallbackHandler;\n    uint256 nonce;\n    address[] modules;\n    address guard;\n}\n\ninterface ISafe {\n    function getOwners() external view returns (address[] memory);\n    function getThreshold() external view returns (uint256);\n    function getStorageAt(\n        uint256 offset,\n        uint256 length\n    ) external view returns (bytes memory);\n    function nonce() external view returns (uint256);\n    function getModulesPaginated(\n        address start,\n        uint256 pageSize\n    ) external view returns (address[] memory array, address next);\n\n    function getModules() external view returns (address[] memory);\n}\n\n/// @title Safe Configuration Fetcher\n/// @notice A utility contract to fetch basic and full configurations of a Safe.\n/// @dev Provides gas-optimized methods for reading storage and modules with pagination.\ncontract SafeConfigurationFetcher {\n    /// @dev Storage slot for fallback handler (keccak256(\"fallback_manager.handler.address\")).\n    bytes32 internal constant FALLBACK_HANDLER_STORAGE_SLOT =\n        0x6c9a6c4a39284e37ed1cf53d337577d14212a4870fb976a4366c693b939918d5;\n\n    /// @dev Storage slot for guard contract (keccak256(\"guard_manager.guard.address\")).\n    bytes32 internal constant GUARD_STORAGE_SLOT =\n        0x4a204f620c8c5ccdca3fd54d003badd85ba500436a431f0cbda4f558c93c34c8;\n\n    /// @dev Sentinel address for module linked-list iteration.\n    address internal constant SENTINEL_MODULES = address(0x1);\n\n    /// @dev Internal helper to read an address from a specific storage slot.\n    /// @param safeContract The Safe contract to query.\n    /// @param slot The storage slot to read.\n    /// @return addr The address value decoded from the slot.\n    function _addressFromStorage(\n        ISafe safeContract,\n        bytes32 slot\n    ) internal view returns (address addr) {\n        addr = abi.decode(\n            safeContract.getStorageAt(uint256(slot), 1),\n            (address)\n        );\n    }\n\n    /// @dev Internal helper to fetch the basic configuration fields from the Safe.\n    /// @param safeContract The Safe contract instance.\n    /// @return config SafeConfiguration struct with owners, threshold, fallbackHandler, nonce, and guard populated.\n    function _fetchBasicConfig(\n        ISafe safeContract\n    ) private view returns (SafeConfiguration memory config) {\n        config.owners = safeContract.getOwners();\n        config.threshold = safeContract.getThreshold();\n        config.fallbackHandler = _addressFromStorage(\n            safeContract,\n            FALLBACK_HANDLER_STORAGE_SLOT\n        );\n        config.nonce = safeContract.nonce();\n        config.guard = _addressFromStorage(safeContract, GUARD_STORAGE_SLOT);\n    }\n\n    /// @notice Returns the basic Safe configuration (excluding modules, modules array will be empty).\n    /// @param safe The address of the Safe contract.\n    /// @return config The basic SafeConfiguration with owners, threshold, fallbackHandler, nonce, guard, and an empty modules array.\n    function getBasicConfiguration(\n        address safe\n    ) external view returns (SafeConfiguration memory config) {\n        config = _fetchBasicConfig(ISafe(safe));\n    }\n\n    /// @notice Returns a page of Safe modules and the next cursor for pagination.\n    /// @param safe The address of the Safe contract.\n    /// @param start The starting module address (use SENTINEL_MODULES for first page).\n    /// @param pageSize The maximum number of modules to retrieve.\n    /// @return modulePage List of module addresses in the retrieved page.\n    /// @return nextCursor Address cursor for the next page (address(0) if end reached).\n    function getModulesPaginated(\n        address safe,\n        address start,\n        uint256 pageSize\n    ) external view returns (address[] memory modulePage, address nextCursor) {\n        (modulePage, nextCursor) = ISafe(safe).getModulesPaginated(\n            start,\n            pageSize\n        );\n    }\n\n    /// @notice Returns the full Safe configuration, including all modules up to the specified cap.\n    /// @param safe The address of the Safe contract.\n    /// @param maxIterations Maximum number of pagination loops.\n    /// @param pageSize Number of modules to fetch per iteration.\n    /// @return fullConfig Complete SafeConfiguration with modules populated.\n    /// @return nextCursor Cursor for additional pagination (address(0) if none left).\n    function getFullConfiguration(\n        address safe,\n        uint256 maxIterations,\n        uint256 pageSize\n    )\n        external\n        view\n        returns (SafeConfiguration memory fullConfig, address nextCursor)\n    {\n        ISafe safeContract = ISafe(safe);\n        fullConfig = _fetchBasicConfig(safeContract);\n\n        uint256 bufferSize = maxIterations * pageSize;\n        address[] memory temp = new address[](bufferSize);\n        uint256 count = 0;\n        address cursor = SENTINEL_MODULES;\n\n        for (\n            uint256 i = 0;\n            i < maxIterations &&\n                (cursor != address(0) && cursor != SENTINEL_MODULES);\n            i++\n        ) {\n            (address[] memory page, address next) = safeContract\n                .getModulesPaginated(cursor, pageSize);\n            for (uint256 j = 0; j < page.length; j++) {\n                temp[count++] = page[j];\n            }\n            cursor = next;\n        }\n\n        address[] memory modulesArr = new address[](count);\n        for (uint256 k = 0; k < count; k++) {\n            modulesArr[k] = temp[k];\n        }\n        fullConfig.modules = modulesArr;\n        nextCursor = cursor;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 10000000
    },
    "viaIR": true,
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}